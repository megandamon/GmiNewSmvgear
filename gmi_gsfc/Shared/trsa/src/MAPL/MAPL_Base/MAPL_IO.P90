
!  $Id: MAPL_IO.P90,v 1.2 2011-08-09 22:12:59 mrdamon Exp $

#include "MAPL_ErrLog.h"

!BOP

! !MODULE: MAPL_IO -- A Module to do I/O (ASCII+binary) until ESMF fully supports it


! !INTERFACE:

module MAPL_IOMod

  use ESMF_Mod
  use MAPL_BaseMod
  use MAPL_CommsMod
  implicit none
  private

  public GETFILE
  public FREE_FILE
  public READ_PARALLEL
  public WRITE_PARALLEL
  public MAPL_VarRead
  public MAPL_VarWrite
  public MAPL_Skip
  public MAPL_Backspace
  public MAPL_Rewind
  public MAPL_ClimUpdate 


! Interfaces:
! -----------

  interface WRITE_PARALLEL
     module procedure WRITE_PARALLEL_I4_0
     module procedure WRITE_PARALLEL_I4_1
     module procedure WRITE_PARALLEL_R4_0
     module procedure WRITE_PARALLEL_R4_1
     module procedure WRITE_PARALLEL_R8_0
     module procedure WRITE_PARALLEL_R8_1
     module procedure WRITE_PARALLEL_STRING_0
  end interface

  interface READ_PARALLEL
     module procedure READ_PARALLEL_STRING_0
     module procedure READ_PARALLEL_I4_0
     module procedure READ_PARALLEL_I4_1
     module procedure READ_PARALLEL_I4_2
     module procedure READ_PARALLEL_R4_0
     module procedure READ_PARALLEL_R4_1
     module procedure READ_PARALLEL_R4_2
     module procedure READ_PARALLEL_R8_0
     module procedure READ_PARALLEL_R8_1
     module procedure READ_PARALLEL_R8_2
  end interface

! -----------------------------------------
  interface MAPL_VarRead
     module procedure MAPL_StateVarRead
     module procedure MAPL_BundleRead 
     module procedure MAPL_FieldRead 
     module procedure MAPL_VarRead_R4_1D
     module procedure MAPL_VarRead_R4_2D
     module procedure MAPL_VarRead_R4_3D
     module procedure MAPL_VarRead_R4_4D
     module procedure MAPL_VarRead_R8_1D
     module procedure MAPL_VarRead_R8_2D
     module procedure MAPL_VarRead_R8_3D
     module procedure MAPL_VarRead_R8_4D
  end interface

  interface MAPL_VarWrite
     module procedure MAPL_StateVarWrite
     module procedure MAPL_VarWrite_I4_1D
     module procedure MAPL_VarWrite_R4_1D
     module procedure MAPL_VarWrite_R4_2D
     module procedure MAPL_VarWrite_R4_3D
     module procedure MAPL_VarWrite_R4_4D
     module procedure MAPL_VarWrite_R8_1D
     module procedure MAPL_VarWrite_R8_2D
     module procedure MAPL_VarWrite_R8_3D
     module procedure MAPL_VarWrite_R8_4D
  end interface


! Global vars:
! ------------

  integer, parameter :: STD_OUT_UNIT_NUMBER = 6
  integer, parameter :: LAST_UNIT = 99
  integer, parameter :: UNDEF = 999
  logical, save      :: TAKEN(LAST_UNIT)=.FALSE.
  logical, save      :: MTAKEN(LAST_UNIT)=.FALSE.
  character(len=ESMF_MAXSTR), save  :: mname(LAST_UNIT)

  integer, parameter :: not_allocated = 0
  integer, parameter :: r4_2 = 1
  integer, parameter :: r4_1 = 2
  integer, parameter :: r8_2 = 3
  integer, parameter :: r8_1 = 4
  integer, parameter :: i4_2 = 5
  integer, parameter :: i4_1 = 6

  type PTR
   integer :: allocated=not_allocated
   real(kind=ESMF_KIND_R4)   , pointer :: r4_2(:,:)
   real(kind=ESMF_KIND_R4)   , pointer :: r4_1(:)
   real(kind=ESMF_KIND_R4)             :: r4_0
   real(kind=ESMF_KIND_R8)   , pointer :: r8_2(:,:)
   real(kind=ESMF_KIND_R8)   , pointer :: r8_1(:)
   real(kind=ESMF_KIND_R8)             :: r8_0
   integer(kind=ESMF_KIND_I4), pointer :: I4_2(:,:)
   integer(kind=ESMF_KIND_I4), pointer :: I4_1(:)
   integer(kind=ESMF_KIND_I4)          :: I4_0
  end type PTR

  type memunit
     integer :: prevrec = 0
     type (PTR), pointer :: Records(:)=>null()
  end type MEMUNIT

  type (memunit), target, save :: MEM_UNITS(LAST_UNIT)
  type (memunit), pointer      :: munit
  type(PTR), pointer           :: REC(:)

  contains


  INTEGER FUNCTION GETFILEMEM(name,  RC )
    IMPLICIT NONE
    character(LEN=*), intent(in   )           :: Name
    integer         , intent(  out), OPTIONAL :: RC

    integer i

    i = 2
    do while (i<=last_unit)
    if(MTAKEN(i)) then
      if(name==Mname(i)) exit
      i = i+ 1
    else
      exit
    endif
    enddo 

    if(i>last_unit) then
        if(present(rc)) rc = 1
        return
    endif

    mname(i)   = name
    mtaken(i)  = .true.
    getfilemem = -i

    if(present(rc)) rc = 0
    return
  end function getfilemem

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


  INTEGER FUNCTION GETFILE( NAME, DO_OPEN, FORM, ALL_PES, &
                             BLOCKSIZE, NUMBUFFERS, RC )
    IMPLICIT NONE

    character(LEN=*), intent(in   )           :: Name
    integer         , intent(in   ), OPTIONAL :: DO_OPEN
    character(LEN=*), intent(in   ), OPTIONAL :: Form
    logical         , intent(in   ), OPTIONAL :: ALL_PES
    integer         , intent(in   ), OPTIONAL :: BLOCKSIZE
    integer         , intent(in   ), OPTIONAL :: NUMBUFFERS
    integer         , intent(  out), OPTIONAL :: RC
    
    INTEGER I
    integer :: DO_OPEN_
    logical :: ALL_PES_
    character(len=ESMF_MAXSTR)     :: Iam="GETFILE"
    integer          :: status
    
    LOGICAL FILEOPEN, UNITOPEN, FOUND 

    if(INDEX(NAME,'*') /= 0) then
        getfile = getfilemem(name,rc=status)
	VERIFY_(STATUS)
        RETURN_(ESMF_SUCCESS) 
    endif

    if (NAME == "stdout" .or. NAME== "STDOUT") then
       GETFILE = STD_OUT_UNIT_NUMBER
       RETURN_(ESMF_SUCCESS) 
    end if

    if (.not. present(DO_OPEN)) then
       DO_OPEN_ = 1
    else
       DO_OPEN_ = DO_OPEN
    end if
    
    ALL_PES_ = .false.
    if (present(ALL_PES)) then
       ALL_PES_ = ALL_PES
    end if
      
    if (.not. MAPL_AM_I_ROOT() .and. .not. ALL_PES_) then
       GETFILE = UNDEF
       RETURN_(ESMF_SUCCESS) 
    end if

!   Check if the file is already open

    INQUIRE ( FILE=NAME, NUMBER=GETFILE, OPENED=FILEOPEN )

!   If the file isnt already open THEN

    IF ( .NOT. FILEOPEN ) THEN
       I = 20
       FOUND = .FALSE.
       DO WHILE ( I.LE.LAST_UNIT .AND. .NOT.FOUND ) 
          IF ( .NOT. TAKEN(I) ) THEN
             TAKEN(I) = .TRUE.
             INQUIRE ( UNIT=I, OPENED=UNITOPEN )
             IF ( .NOT. UNITOPEN ) THEN
                
                status = 0
                
                if ( DO_OPEN_ .NE. 0 ) then
                   call MAPL_open(UNIT=i,FILE=Name,FORM=FORM, &
                                  BLOCKSIZE= BLOCKSIZE, NUMBUFFERS=NUMBUFFERS, RC=STATUS)
                endif
                
                if ( status /= 0 ) then
                   write (0,*) 'ERROR opening "',Name,'" using GETFILE'
                   write (0,*) ' IOSTAT = ',status
                   RETURN_(ESMF_FAILURE)
                endif
               
                GETFILE = I
                FOUND = .TRUE.
             ENDIF
          ENDIF
          I = I + 1
       ENDDO
!
!      IF there are no available logical units THEN
!         Write an error message
!         Return Error status
!      ENDIF there are no available logical units
!  
       IF ( .NOT. FOUND ) THEN
          WRITE (0,*) ' COULD NOT FIND ANY AVAILABLE UNITS '
          RETURN_(ESMF_FAILURE)
       ENDIF

    ENDIF ! the file isnt already open 

    RETURN_(ESMF_SUCCESS) 
  END FUNCTION GETFILE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE FREE_FILE(UNIT, RC)
    implicit none
    integer         , intent(out), OPTIONAL :: RC

    character(len=ESMF_MAXSTR)     :: Iam="FREE_FILE"
    integer          :: status
    integer :: UNIT
    logical :: ALL_OPEN_

    if(UNIT < 0) then

      ASSERT_(-UNIT<=LAST_UNIT)
      ASSERT_(MTAKEN(-UNIT))
      MEM_units(-unit)%PREVREC=0

    ELSE

    if (UNIT == STD_OUT_UNIT_NUMBER) return
    if (UNIT /= UNDEF) then
       close(UNIT)

       IF (UNIT.LT.1 .OR. UNIT.GT.LAST_UNIT) THEN
          WRITE (0,*) ' BAD UNIT NUMBER  ZFILCLR  UNIT = ', UNIT
          RETURN_(ESMF_FAILURE)
       ELSE
          TAKEN(UNIT) = .FALSE.
       ENDIF
    end if

    END IF

    RETURN_(ESMF_SUCCESS)
  END SUBROUTINE FREE_FILE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine MAPL_OPEN(UNIT,FILE,FORM,BLOCKSIZE, NUMBUFFERS, RC)

    implicit none
    integer         , intent(out), OPTIONAL :: RC

    integer         ,  intent(in) :: UNIT
    character(LEN=*),  intent(in) :: FILE
    character(LEN=*),  intent(in) :: FORM
    integer, optional, intent(in) :: BLOCKSIZE, NUMBUFFERS
    character(len=ESMF_MAXSTR)     :: Iam="MAPL_OPEN"
    integer          :: status

    if(MAPL_AM_I_ROOT()) then
       if(.not.present(BLOCKSIZE) .and. .not.present(NUMBUFFERS)) then
          print *, "NOT using buffer I/O for file: ", trim(file)
       else
          print *, "Using buffer I/O for file: ", trim(file)
       endif
    endif
        
    open(UNIT,FILE=FILE,FORM=FORM,IOSTAT=STATUS)
    VERIFY_(STATUS)

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_OPEN

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!--WRITES ------------------

!---------------------------
#define RANK_ 0
#define VARTYPE_ 1
#include "write_parallel.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 1
#include "write_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 3
#include "write_parallel.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 3
#include "write_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 4
#include "write_parallel.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 4
#include "write_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 0
#include "write_parallel.H"


!-READS --------------------

! Rank 0
!---------------------------
#define RANK_ 0
#define VARTYPE_ 0
#include "read_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 1
#include "read_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 3
#include "read_parallel.H"

!---------------------------
#define RANK_ 0
#define VARTYPE_ 4
#include "read_parallel.H"

! Rank 1
!---------------------------
#define RANK_ 1
#define VARTYPE_ 1
#include "read_parallel.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 3
#include "read_parallel.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 4
#include "read_parallel.H"

! Rank 2
!---------------------------
#define RANK_ 2
#define VARTYPE_ 1
#include "read_parallel.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 3
#include "read_parallel.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 4
#include "read_parallel.H"

!---------------------------
! Read routines
!---------------------------

  subroutine MAPL_StateVarRead(UNIT, STATE, NAME, RC)
    integer                     , intent(IN   ) :: UNIT
    type (ESMF_State)           , intent(INOUT) :: STATE
    character(len=*),   optional, intent(IN   ) :: NAME
    integer,            optional, intent(  OUT) :: RC

! Local vars
    type (ESMF_Bundle)                 :: bundle
    type (ESMF_Field)                  :: field
    integer                            :: status
    integer                            :: I, N
    character(len=ESMF_MAXSTR)         :: IAm='MAPL_StateVarRead'
    integer                              :: J, ITEMCOUNT
    type (ESMF_StateItemType), pointer   :: ITEMTYPES(:)
    character(len=ESMF_MAXSTR ), pointer :: ITEMNAMES(:)
    logical, pointer                     :: DOIT(:)
    
    call ESMF_StateGet(STATE,ITEMCOUNT=ITEMCOUNT,RC=STATUS)
    VERIFY_(STATUS)

    ASSERT_(ITEMCOUNT>0)

    allocate(ITEMNAMES(ITEMCOUNT),STAT=STATUS)
    VERIFY_(STATUS)
    allocate(ITEMTYPES(ITEMCOUNT),STAT=STATUS)
    VERIFY_(STATUS)
    allocate(     DOIT(ITEMCOUNT),STAT=STATUS)
    VERIFY_(STATUS)

    call ESMF_StateGet(STATE,ITEMNAMELIST=ITEMNAMES,STATEITEMTYPELIST=ITEMTYPES,RC=STATUS)
    VERIFY_(STATUS)

    if(present(NAME)) then
       DOIT = ITEMNAMES==NAME
       ASSERT_(count(DOIT)/=0)
    else
       DOIT = .true.
    endif

    DO I = 1, ITEMCOUNT
       IF (DOIT(I)) then
          IF (ITEMTYPES(I) == ESMF_StateItem_Bundle) then
             call ESMF_StateGetBundle(state, itemnames(i), bundle, rc=status)
             VERIFY_(STATUS)

             call MAPL_BundleRead(unit, bundle, rc=status)
             VERIFY_(STATUS)

          ELSE IF (ITEMTYPES(I) == ESMF_StateItem_Field) THEN
             call ESMF_StateGetField(state, itemnames(i), field, rc=status)
             VERIFY_(STATUS)

             call MAPL_FieldRead(unit, field, rc=status)
             VERIFY_(STATUS)
          end IF
       END IF
    END DO

    deallocate(ITEMNAMES)
    deallocate(ITEMTYPES)
    deallocate(     DOIT)

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_StateVarRead
!---------------------------


  subroutine MAPL_BundleRead(UNIT,BUNDLE, RC)
    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Bundle)          , intent(INOUT) :: BUNDLE
    integer,           optional , intent(  OUT) :: RC


    integer                            :: status
    integer                            :: J, N
    character(len=ESMF_MAXSTR)         :: IAm='MAPL_BundleRead'
    type (ESMF_Field)                  :: field

             call ESMF_BundleGet(bundle, fieldCount=N,  rc=STATUS)
             VERIFY_(STATUS)

             DO J = 1, N
                call ESMF_BundleGetField(bundle, fieldIndex=J, field=field, rc=status)
                VERIFY_(STATUS)

                call MAPL_FieldRead(unit, field, rc=status)
                VERIFY_(STATUS)

             END DO

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_BundleRead


  subroutine MAPL_FieldRead(UNIT,FIELD, RC)
    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Field)           , intent(INOUT) :: field
    integer,           optional , intent(  OUT) :: RC

! Local vars
    type (ESMF_Array)                  :: array
    type (ESMF_DELayout)               :: layout
    type (ESMF_Grid)                   :: GRID
    integer                            :: rank
    integer                            :: status
    real(KIND=ESMF_KIND_R4), pointer, dimension(:)        :: var_1d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:)      :: var_2d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:,:)    :: var_3d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:,:,:)  :: var_4d

    real(KIND=ESMF_KIND_R8), pointer, dimension(:)        :: vr8_1d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:)      :: vr8_2d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:,:)    :: vr8_3d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:,:,:)  :: vr8_4d
    type(ESMF_DataKind)                :: knd
    character(len=ESMF_MAXSTR)         :: FORMATTED
    integer                            :: count
    integer                            :: counts(ESMF_MAXDIM)
    integer                            :: dims
    integer, pointer                   :: mask(:)
    character(len=ESMF_MAXSTR)         :: IAm='MAPL_FieldRead'

    
    inquire(unit=UNIT, formatted=FORMATTED)

    call ESMF_FieldGet(field, grid, rc=status)
    VERIFY_(STATUS)
    call ESMF_GridGet(grid, deLayout=layout, rc=status)
    VERIFY_(STATUS)

    call ESMF_FieldGetAttribute(field, name='DIMS', value=DIMS, rc=status)
    VERIFY_(STATUS)
    if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
       call ESMF_GridGetAttributeInfo(grid, name='ISMINE_mask', count=count, rc=status)
       VERIFY_(STATUS)
       allocate(mask(count), stat=status)
       VERIFY_(STATUS)
       call ESMF_GridGetAttribute(grid, 'ISMINE_mask', count, mask, rc=status)
       VERIFY_(STATUS)
    end if

    call ESMF_FieldGetArray(field, array, rc=status)
    VERIFY_(STATUS)
    call ESMF_ArrayGet(array, rank, kind=knd, rc=status)
    VERIFY_(STATUS)
    if (rank == 1) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_1d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_1d)) then !ALT: temp kludge
             call ESMF_GridGetDELocalInfo(grid, horzRelLoc=ESMF_CELL_CENTER,  &
                  localCellCountPerDim=COUNTS,RC=STATUS)
             VERIFY_(STATUS)
             if (COUNTS(1) == size(var_1d)) then
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarRead(unit, grid, var_1d, mask=mask, rc=status)
                else
                   call MAPL_VarRead(unit, grid, var_1d, rc=status)
                endif
             else
                call READ_PARALLEL(layout, var_1d, unit, rc=status)
             end if
          end if
       else
          call ESMF_ArrayGetData(array, vr8_1d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_1d)) then !ALT: temp kludge
             call ESMF_GridGetDELocalInfo(grid, horzRelLoc=ESMF_CELL_CENTER,  &
                  localCellCountPerDim=COUNTS,RC=STATUS)
             VERIFY_(STATUS)
             if (COUNTS(1) == size(vr8_1d)) then
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarRead(unit, grid, vr8_1d, mask=mask, rc=status)
                else
                   call MAPL_VarRead(unit, grid, vr8_1d, rc=status)
                endif
             else
                call READ_PARALLEL(layout, vr8_1d, unit, rc=status)
             end if
          end if
       end if
    else if (rank == 2) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_2d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_2d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call READ_PARALLEL(layout, &
                     var_2d(lbound(var_3d,1),:), unit, rc=status)
             else
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarRead(unit, grid, var_2d, mask=mask, rc=status)
                else
                   call MAPL_VarRead(unit, grid, var_2d, rc=status)
                end if
             end if
          end if
       else
          call ESMF_ArrayGetData(array, vr8_2d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_2d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call READ_PARALLEL(layout, &
                     vr8_2d(lbound(vr8_3d,1),:), unit, rc=status)
             else
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarRead(unit, grid, vr8_2d, mask=mask, rc=status)
                else
                   call MAPL_VarRead(unit, grid, vr8_2d, rc=status)
                end if
             end if
          end if
       endif
    else if (rank == 3) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_3d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_3d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call READ_PARALLEL(layout, &
                     var_3d(lbound(var_3d,1),lbound(var_3d,2),:), unit)
             else
                call MAPL_VarRead(unit, grid, var_3d, rc=status)
             endif
          end if
       else
          call ESMF_ArrayGetData(array, vr8_3d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_3d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call READ_PARALLEL(layout, &
                     vr8_3d(lbound(vr8_3d,1),lbound(vr8_3d,2),:), unit)
             else
                call MAPL_VarRead(unit, grid, vr8_3d, rc=status)
             endif
          end if
       endif
    else if (rank == 4) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_4d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          call MAPL_VarRead(unit, grid, var_4d, rc=status)
       else
          call ESMF_ArrayGetData(array, vr8_4d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          call MAPL_VarRead(unit, grid, vr8_4d, rc=status)
       end if
    else
       print *, "ERROR: unsupported RANK"
       RETURN_(ESMF_FAILURE)
    endif
    VERIFY_(STATUS)

    if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
       deallocate(mask)
    end if

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_FieldRead

!---------------------------

  subroutine MAPL_VarRead_R4_1d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(  OUT) :: A(:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R4),  allocatable :: VAR(:)
    integer                               :: IM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R4_1d'

    if(unit < 0) then

       ASSERT_(-UNIT<=LAST_UNIT)
       munit => MEM_units(-unit)
       munit%prevrec = munit%prevrec + 1
       ASSERT_(associated(munit%Records(munit%prevrec)%R4_1))
       ASSERT_(size(A)==size(munit%Records(munit%prevrec)%R4_1))
       A = munit%Records(munit%prevrec)%R4_1

    else


    call ESMF_GridGet(GRID, &
		      horzRelLoc=ESMF_CELL_CENTER, &
		      globalCellCountPerDim=DIMS, RC=STATUS)
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)

    allocate(VAR(IM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    if (MAPL_am_i_root(layout)) then
       read (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if

    call ArrayScatter(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R4_1d

!---------------------------

  subroutine MAPL_VarRead_R4_2d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(  OUT) :: A(:,:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R4),  allocatable :: VAR(:,:)
    integer                               :: IM_WORLD
    integer                               :: JM_WORLD
    integer                               :: status
    integer                               :: gridRank
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R4_2d'

    if(unit < 0) then

      ASSERT_(-UNIT<=LAST_UNIT)
      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      ASSERT_(associated(munit%Records(munit%prevrec)%R4_2))
      ASSERT_(size(A)==size(munit%Records(munit%prevrec)%R4_2))
      A = munit%Records(munit%prevrec)%R4_2

    else


    call ESMF_GridGet(GRID, dimCount=gridRank, rc=STATUS)
    VERIFY_(STATUS)
    if (gridRank == 3) then
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            vertRelLoc=ESMF_CELL_CELL, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    else ! if (gridRank == 2)
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    end if
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)
    JM_WORLD = DIMS(2)

    allocate(VAR(IM_WORLD,JM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    if (MAPL_am_i_root(layout)) then
       read (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if

    call ArrayScatter(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    
    deallocate(VAR)

    END IF
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R4_2d

!---------------------------
  subroutine MAPL_VarRead_R4_3d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(  OUT) :: A(:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R4_3d'

    integer :: L

    do L = 1, size(A,3)
       call MAPL_VarRead(UNIT, GRID, A(:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R4_3d
  
!---------------------------
  subroutine MAPL_VarRead_R4_4d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(  OUT) :: A(:,:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R4_4d'

    integer :: L

    do L = 1, size(A,4)
       call MAPL_VarRead(UNIT, GRID, A(:,:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R4_4d
  
!---------------------------
  subroutine MAPL_VarRead_R8_1d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(  OUT) :: A(:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R8),  allocatable :: VAR(:)
    integer                               :: IM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R8_1d'

    if(unit < 0) then

       ASSERT_(-UNIT<=LAST_UNIT)
       munit => MEM_units(-unit)
       munit%prevrec = munit%prevrec + 1
       ASSERT_(associated(munit%Records(munit%prevrec)%R8_1))
       ASSERT_(size(A)==size(munit%Records(munit%prevrec)%R8_1))
       A = munit%Records(munit%prevrec)%R8_1

    else


    call ESMF_GridGet(GRID, &
		      horzRelLoc=ESMF_CELL_CENTER, &
		      globalCellCountPerDim=DIMS, RC=STATUS)
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)

    allocate(VAR(IM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    if (MAPL_am_i_root(layout)) then
       read (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if

    call ArrayScatter(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R8_1d

!---------------------------


  subroutine MAPL_VarRead_R8_2d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(  OUT) :: A(:,:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R8),  allocatable :: VAR(:,:)
    integer                               :: IM_WORLD
    integer                               :: JM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    integer                               :: gridRank
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R8_2d'

    if(unit < 0) then

      ASSERT_(-UNIT<=LAST_UNIT)
      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      ASSERT_(associated(munit%Records(munit%prevrec)%R8_2))
      ASSERT_(size(A)==size(munit%Records(munit%prevrec)%R8_2))
      A = munit%Records(munit%prevrec)%R8_2

    else


    call ESMF_GridGet(GRID, dimCount=gridRank, rc=STATUS)
    VERIFY_(STATUS)
    if (gridRank == 3) then
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            vertRelLoc=ESMF_CELL_CELL, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    else ! if (gridRank == 2)
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    end if
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)
    JM_WORLD = DIMS(2)

    allocate(VAR(IM_WORLD,JM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    if (MAPL_am_i_root(layout)) then
       read (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    call ArrayScatter(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    
    deallocate(VAR)

    END IF
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R8_2d

!---------------------------
  subroutine MAPL_VarRead_R8_3d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(  OUT) :: A(:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R8_3d'

    integer :: L

    do L = 1, size(A,3)
       call MAPL_VarRead(UNIT, GRID, A(:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R8_3d
  
!---------------------------
  subroutine MAPL_VarRead_R8_4d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(  OUT) :: A(:,:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarRead_R8_4d'

    integer :: L

    do L = 1, size(A,4)
       call MAPL_VarRead(UNIT, GRID, A(:,:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarRead_R8_4d
  
!---------------------------
! Write routines
!---------------------------

  subroutine MAPL_StateVarWrite(UNIT, STATE, NAME, RC)
    integer                     , intent(IN   ) :: UNIT
    type (ESMF_State)           , intent(IN   ) :: STATE
    character(len=*)            , intent(IN   ) :: NAME
    integer,            optional, intent(  OUT) :: RC

! Local vars
    type (ESMF_Bundle)                   :: bundle
    type (ESMF_Field)                    :: field
    integer                              :: status
    integer                              :: I, J, N, ITEMCOUNT
    logical                              :: FOUND
    type (ESMF_StateItemType), pointer   :: ITEMTYPES(:)
    character(len=ESMF_MAXSTR ), pointer :: ITEMNAMES(:)
    character(len=ESMF_MAXSTR)           :: IAm='MAPL_StateVarWrite'
    
    
    call ESMF_StateGet(STATE,ITEMCOUNT=ITEMCOUNT,RC=STATUS)
    VERIFY_(STATUS)

    ASSERT_(ITEMCOUNT>0)

    allocate(ITEMNAMES(ITEMCOUNT),STAT=STATUS)
    VERIFY_(STATUS)
    allocate(ITEMTYPES(ITEMCOUNT),STAT=STATUS)
    VERIFY_(STATUS)

    call ESMF_StateGet(STATE,ITEMNAMELIST=ITEMNAMES,STATEITEMTYPELIST=ITEMTYPES,RC=STATUS)
    VERIFY_(STATUS)


    FOUND = .FALSE.

    DO I = 1, ITEMCOUNT
       IF (ITEMNAMES(I) == NAME) then
          FOUND = .true.
          IF (ITEMTYPES(I) == ESMF_StateItem_Bundle) then
             call ESMF_StateGetBundle(state, name, bundle, rc=status)
             VERIFY_(STATUS)

             call ESMF_BundleGet(bundle, fieldCount=N,  rc=STATUS)
             VERIFY_(STATUS)

             DO J = 1, N
                call ESMF_BundleGetField(bundle, fieldIndex=J, field=field, rc=status)
                VERIFY_(STATUS)

                call MAPL_FieldWrite(unit, field, rc=status)
                VERIFY_(STATUS)

             END DO

          ELSE IF (ITEMTYPES(I) == ESMF_StateItem_Field) THEN
             call ESMF_StateGetField(state, name, field, rc=status)
             VERIFY_(STATUS)

             call MAPL_FieldWrite(unit, field, rc=status)
             VERIFY_(STATUS)
          end IF
       END IF

    END DO

    deallocate(ITEMNAMES)
    deallocate(ITEMTYPES)
    
    IF (.not. FOUND) then
       RETURN_(ESMF_FAILURE)
    END IF

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_StateVarWrite
!---------------------------

  subroutine MAPL_FieldWrite(UNIT,FIELD, RC)
    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Field)           , intent(IN   ) :: field
    integer,           optional , intent(  OUT) :: RC

! Local vars
    type (ESMF_Array)                  :: array
    type (ESMF_DELayout)               :: layout
    type (ESMF_Grid)                   :: GRID
    integer                            :: rank
    integer                            :: status
    integer                            :: DIMS
    real(KIND=ESMF_KIND_R4), pointer, dimension(:)        :: var_1d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:)      :: var_2d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:,:)    :: var_3d
    real(KIND=ESMF_KIND_R4), pointer, dimension(:,:,:,:)  :: var_4d

    real(KIND=ESMF_KIND_R8), pointer, dimension(:)        :: vr8_1d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:)      :: vr8_2d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:,:)    :: vr8_3d
    real(KIND=ESMF_KIND_R8), pointer, dimension(:,:,:,:)  :: vr8_4d
    type(ESMF_DataKind)                :: knd
    integer, pointer                   :: mask(:)
    character(len=ESMF_MAXSTR)         :: FORMATTED
    integer                            :: count
    integer                            :: counts(ESMF_MAXDIM)
    character(len=ESMF_MAXSTR)         :: IAm='MAPL_FieldWrite'

    inquire(unit=UNIT, formatted=FORMATTED)

    call ESMF_FieldGet(field, grid, rc=status)
    VERIFY_(STATUS)
    call ESMF_GridGet(grid, deLayout=layout, rc=status)
    VERIFY_(STATUS)

    call ESMF_FieldGetAttribute(field, name='DIMS', value=DIMS, rc=status)
    VERIFY_(STATUS)
    if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
       call ESMF_GridGetAttributeInfo(grid, name='ISMINE_mask', count=count, rc=status)
       VERIFY_(STATUS)
       allocate(mask(count), stat=status)
       VERIFY_(STATUS)
       call ESMF_GridGetAttribute(grid, 'ISMINE_mask', count, mask, rc=status)
       VERIFY_(STATUS)
    end if

    call ESMF_FieldGetArray(field, array, rc=status)
    VERIFY_(STATUS)
    call ESMF_ArrayGet(array, rank, kind=knd, rc=status)
    VERIFY_(STATUS)
    if (rank == 1) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_1d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_1d)) then !ALT: temp kludge
             call ESMF_GridGetDELocalInfo(grid, horzRelLoc=ESMF_CELL_CENTER,  &
                  localCellCountPerDim=COUNTS,RC=STATUS)
             VERIFY_(STATUS)
             if (COUNTS(1) == size(var_1d)) then
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarWrite(unit, grid, var_1d, mask=mask, rc=status)
                else
                   call MAPL_VarWrite(unit, grid, var_1d, rc=status)
                end if
             else
                call WRITE_PARALLEL(var_1d, unit, rc=status)
             end if
          end if
       else
          call ESMF_ArrayGetData(array, vr8_1d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_1d)) then !ALT: temp kludge
             call ESMF_GridGetDELocalInfo(grid, horzRelLoc=ESMF_CELL_CENTER,  &
                  localCellCountPerDim=COUNTS,RC=STATUS)
             VERIFY_(STATUS)
             if (COUNTS(1) == size(vr8_1d)) then
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarWrite(unit, grid, vr8_1d, mask=mask, rc=status)
                else
                   call MAPL_VarWrite(unit, grid, vr8_1d, rc=status)
                end if
             else
                call WRITE_PARALLEL(vr8_1d, unit, rc=status)
             end if
          end if
       endif
    else if (rank == 2) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_2d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_2d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call WRITE_PARALLEL( &
                     var_2d(lbound(var_3d,1),:), unit, rc=status)
             else
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarWrite(unit, grid, var_2d, mask=mask, rc=status)
                else
                   call MAPL_VarWrite(unit, grid, var_2d, rc=status)
                end if
             end if
          end if
       else
          call ESMF_ArrayGetData(array, vr8_2d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_2d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call WRITE_PARALLEL( &
                     vr8_2d(lbound(vr8_3d,1),:), unit, rc=status)
             else
                if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
                   call MAPL_VarWrite(unit, grid, vr8_2d, mask=mask, rc=status)
                else
                   call MAPL_VarWrite(unit, grid, vr8_2d, rc=status)
                end if
             end if
          end if
       endif
    else if (rank == 3) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_3d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(var_3d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call WRITE_PARALLEL( &
                     var_3d(lbound(var_3d,1),lbound(var_3d,2),:), unit)
             else
                call MAPL_VarWrite(unit, grid, var_3d, rc=status)
             endif
          end if
       else
          call ESMF_ArrayGetData(array, vr8_3d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          if (associated(vr8_3d)) then !ALT: temp kludge
             if (FORMATTED=="YES") THEN
                call WRITE_PARALLEL( &
                     vr8_3d(lbound(vr8_3d,1),lbound(vr8_3d,2),:), unit)
             else
                call MAPL_VarWrite(unit, grid, vr8_3d, rc=status)
             endif
          end if
       endif
    else if (rank == 4) then
       if (knd == ESMF_R4) then
          call ESMF_ArrayGetData(array, var_4d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          call MAPL_VarWrite(unit, grid, var_4d, rc=status)
       else
          call ESMF_ArrayGetData(array, vr8_4d, ESMF_DATA_REF, rc=status)
          VERIFY_(STATUS)
          call MAPL_VarWrite(unit, grid, vr8_4d, rc=status)
       endif
    else
       print *, "ERROR: unsupported RANK"
       RETURN_(ESMF_FAILURE)
    endif
    VERIFY_(STATUS)

    if (DIMS == MAPL_DimsTileOnly .or. DIMS == MAPL_DimsTileTile) then
       deallocate(mask)
    end if

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_FieldWrite


  subroutine alloc_(A,type,im,jm,rc)
    type (Ptr),        intent(INOUT) :: A
    integer,           intent(IN)    :: TYPE
    integer,           intent(IN)    :: IM
    integer, optional, intent(IN)    :: JM
    integer, optional, intent(out)   :: rc

    integer :: status
    character(len=ESMF_MAXSTR)         :: IAm='alloc_'

    call dealloc_(A,RC=STATUS)
    VERIFY_(STATUS)

    select case (type)
    case (R4_2)
       ASSERT_(present(jm))
       allocate(A%r4_2(IM,JM))
    case (R4_1)
       ASSERT_(.not.present(jm))
       allocate(A%r4_1(IM))
    case (R8_2) 
       ASSERT_(present(jm))
       allocate(A%r8_2(IM,JM))
    case (R8_1) 
       ASSERT_(.not.present(jm))
       allocate(A%r8_1(IM))
    case (i4_1) 
       ASSERT_(.not.present(jm))
       allocate(A%I4_1(IM))
    case (i4_2) 
       ASSERT_(present(jm))
       allocate(A%I4_2(IM,JM))
    case default
       ASSERT_(.false.)
    end select

    a%allocated=type

    RETURN_(ESMF_SUCCESS)
  end subroutine alloc_


  subroutine dealloc_(A,RC)
    type (Ptr), intent(INOUT)        :: A
    integer, optional, intent(out)   :: rc

    integer :: status
    character(len=ESMF_MAXSTR)         :: IAm='dealloc_'

    if(a%allocated/=not_allocated) then
       select case (a%allocated)
       case (R4_2) 
          if(associated(A%r4_2)) deallocate(A%r4_2)
       case (R4_1) 
          if(associated(A%r4_1)) deallocate(A%r4_1)
       case (R8_2) 
          if(associated(A%r8_2)) deallocate(A%r8_2)
       case (R8_1) 
          if(associated(A%r8_1)) deallocate(A%r8_1)
       case (i4_1) 
          if(associated(A%i4_1)) deallocate(A%i4_1)
       case (i4_2) 
          if(associated(A%i4_2)) deallocate(A%i4_2)
       case default
          ASSERT_(.false.)
       end select
       a%allocated=not_allocated
    end if

    RETURN_(ESMF_SUCCESS)
  end subroutine dealloc_

!---------------------------
  subroutine MAPL_VarWrite_I4_1d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    integer(kind=ESMF_KIND_I4)  , intent(IN   ) :: A(:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    integer(kind=ESMF_KIND_I4),  allocatable :: VAR(:)
    integer                               :: IM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_I4_1d'

    if(unit < 0) then

      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      if(.not.associated(munit%Records)) then
         allocate(munit%Records(16),stat=status)
         VERIFY_(STATUS)
      elseif(size(munit%Records)< munit%prevrec) then
         allocate(REC(munit%prevrec*2),stat=status)
         VERIFY_(STATUS)
         REC(:munit%prevrec-1) = munit%Records
         deallocate(munit%Records)
         munit%Records => REC
      endif
      call alloc_(munit%Records(munit%prevrec),i4_1,size(A),rc=status)	
      VERIFY_(STATUS)
      munit%Records(munit%prevrec)%I4_1  = A

    else

    call ESMF_GridGet(GRID, &
		      horzRelLoc=ESMF_CELL_CENTER, &
		      globalCellCountPerDim=DIMS, RC=STATUS)
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)

    allocate(VAR(IM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    call ArrayGather(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    if (MAPL_am_i_root(layout)) then
       write (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    
    deallocate(VAR)

    endif

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_I4_1d

!---------------------------
  subroutine MAPL_VarWrite_R4_1d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(IN   ) :: A(:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R4),  allocatable :: VAR(:)
    integer                               :: IM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R4_1d'

    if(unit < 0) then

      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      if(.not.associated(munit%Records)) then
         allocate(munit%Records(16),stat=status)
         VERIFY_(STATUS)
      elseif(size(munit%Records)< munit%prevrec) then
         allocate(REC(munit%prevrec*2),stat=status)
         VERIFY_(STATUS)
         REC(:munit%prevrec-1) = munit%Records
         deallocate(munit%Records)
         munit%Records => REC
      endif
      call alloc_(munit%Records(munit%prevrec),R4_1,size(A),rc=status)	
      VERIFY_(STATUS)
      munit%Records(munit%prevrec)%R4_1  = A

    else

    call ESMF_GridGet(GRID, &
		      horzRelLoc=ESMF_CELL_CENTER, &
		      globalCellCountPerDim=DIMS, RC=STATUS)
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)

    allocate(VAR(IM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    call ArrayGather(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    if (MAPL_am_i_root(layout)) then
       write (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R4_1d

!---------------------------

  subroutine MAPL_VarWrite_R4_2d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(IN   ) :: A(:,:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R4),  allocatable :: VAR(:,:)
    integer                               :: IM_WORLD
    integer                               :: JM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    integer                               :: gridRank
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R4_2d'

    if(unit < 0) then

      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      if(.not.associated(munit%Records)) then
         allocate(munit%Records(16),stat=status)
         VERIFY_(STATUS)
      elseif(size(munit%Records)< munit%prevrec) then
         allocate(REC(munit%prevrec*2),stat=status)
         VERIFY_(STATUS)
         REC(:munit%prevrec-1) = munit%Records
         deallocate(munit%Records)
         munit%Records => REC
      endif
      call alloc_(munit%Records(munit%prevrec),r4_2,size(A,1),size(a,2),rc=status)	
      VERIFY_(STATUS)
      munit%Records(munit%prevrec)%R4_2  = A

    else

    call ESMF_GridGet(GRID, dimCount=gridRank, rc=STATUS)
    VERIFY_(STATUS)
    if (gridRank == 3) then
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            vertRelLoc=ESMF_CELL_CELL, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    else ! if (gridRank == 2)
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    end if
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)
    JM_WORLD = DIMS(2)

    allocate(VAR(IM_WORLD,JM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    call ArrayGather(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    if (MAPL_am_i_root(layout)) then
       write (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R4_2d

!---------------------------
  subroutine MAPL_VarWrite_R4_3d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(IN   ) :: A(:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R4_3d'

    integer :: L

    do L = 1, size(A,3)
       call MAPL_VarWrite(UNIT, GRID, A(:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R4_3d
  
!---------------------------
  subroutine MAPL_VarWrite_R4_4d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R4)     , intent(IN   ) :: A(:,:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R4_4d'

    integer :: L

    do L = 1, size(A,4)
       call MAPL_VarWrite(UNIT, GRID, A(:,:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R4_4d
  
!---------------------------
  subroutine MAPL_VarWrite_R8_1d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(IN   ) :: A(:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R8),  allocatable :: VAR(:)
    integer                               :: IM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R8_1d'

    if(unit < 0) then

      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      if(.not.associated(munit%Records)) then
         allocate(munit%Records(16),stat=status)
         VERIFY_(STATUS)
      elseif(size(munit%Records)< munit%prevrec) then
         allocate(REC(munit%prevrec*2),stat=status)
         VERIFY_(STATUS)
         REC(:munit%prevrec-1) = munit%Records
         deallocate(munit%Records)
         munit%Records => REC
      endif
      call alloc_(munit%Records(munit%prevrec),R8_1,size(A),rc=status)	
      VERIFY_(STATUS)
      munit%Records(munit%prevrec)%R8_1  = A

    else

    call ESMF_GridGet(GRID, &
		      horzRelLoc=ESMF_CELL_CENTER, &
		      globalCellCountPerDim=DIMS, RC=STATUS)
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)

    allocate(VAR(IM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    call ArrayGather(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    if (MAPL_am_i_root(layout)) then
       write (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R8_1d

!---------------------------

  subroutine MAPL_VarWrite_R8_2d(UNIT, GRID, A, MASK, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(IN   ) :: A(:,:)
    integer,           optional , intent(IN   ) :: MASK(:)
    integer,           optional , intent(  OUT) :: RC

! Local variables
    real(kind=ESMF_KIND_R8),  allocatable :: VAR(:,:)
    integer                               :: IM_WORLD
    integer                               :: JM_WORLD
    integer                               :: status
    integer                               :: DIMS(ESMF_MAXGRIDDIM)
    integer                               :: gridRank
    type (ESMF_DELayout)                  :: layout
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R8_2d'

    if(unit < 0) then

      munit => MEM_units(-unit)
      munit%prevrec = munit%prevrec + 1
      if(.not.associated(munit%Records)) then
         allocate(munit%Records(16),stat=status)
         VERIFY_(STATUS)
      elseif(size(munit%Records)< munit%prevrec) then
         allocate(REC(munit%prevrec*2),stat=status)
         VERIFY_(STATUS)
         REC(:munit%prevrec-1) = munit%Records
         deallocate(munit%Records)
         munit%Records => REC
      endif
      call alloc_(munit%Records(munit%prevrec),r8_2,size(A,1),size(a,2),rc=status)	
      VERIFY_(STATUS)
      munit%Records(munit%prevrec)%R8_2  = A

    else


    call ESMF_GridGet(GRID, dimCount=gridRank, rc=STATUS)
    VERIFY_(STATUS)
    if (gridRank == 3) then
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            vertRelLoc=ESMF_CELL_CELL, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    else ! if (gridRank == 2)
       call ESMF_GridGet(GRID, horzRelLoc=ESMF_CELL_CENTER, &
            globalCellCountPerDim=DIMS, RC=STATUS)
    end if
    VERIFY_(STATUS)

    IM_WORLD = DIMS(1)
    JM_WORLD = DIMS(2)

    allocate(VAR(IM_WORLD,JM_WORLD), stat=status)
    VERIFY_(STATUS)

    call ESMF_GridGet(grid, delayout=layout, rc=status)
    VERIFY_(STATUS)

    call ArrayGather(A, VAR, grid, mask=mask, rc=status)
    VERIFY_(STATUS)
    if (MAPL_am_i_root(layout)) then
       write (UNIT, IOSTAT=status) VAR
       VERIFY_(STATUS)
    end if
    
    deallocate(VAR)

    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R8_2d

!---------------------------
  subroutine MAPL_VarWrite_R8_3d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(IN   ) :: A(:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R8_3d'

    integer :: L

    do L = 1, size(A,3)
       call MAPL_VarWrite(UNIT, GRID, A(:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R8_3d
  
!---------------------------
  subroutine MAPL_VarWrite_R8_4d(UNIT, GRID, A, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_Grid)            , intent(IN   ) :: GRID
    real(kind=ESMF_KIND_R8)     , intent(IN   ) :: A(:,:,:,:)
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: status
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_VarWrite_R8_4d'

    integer :: L

    do L = 1, size(A,4)
       call MAPL_VarWrite(UNIT, GRID, A(:,:,:,L), rc=status)
       VERIFY_(STATUS)
    end do

    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_VarWrite_R8_4d
  
!---------------------------
!---------------------------
!---------------------------

!---------------------------
#define RANK_ 1
#define VARTYPE_ 3
#include "arrayscatter.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 4
#include "arrayscatter.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 3
#include "arrayscatter.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 4
#include "arrayscatter.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 3
#include "arraygather.H"

!---------------------------
#define RANK_ 1
#define VARTYPE_ 4
#include "arraygather.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 3
#include "arraygather.H"

!---------------------------
#define RANK_ 2
#define VARTYPE_ 4
#include "arraygather.H"


!---------------------------
!---------------------------


    subroutine MAPL_ClimUpdate ( STATE, BEFORE, AFTER, &
                                 CURRENT_TIME, NAMES, FILE, RC )
        type(ESMF_State),       intent(INOUT) :: STATE
        type(ESMF_Time),        intent(  out) :: BEFORE, AFTER
        type(ESMF_Time),        intent(in   ) :: CURRENT_TIME
        character(len=*),       intent(in   ) :: NAMES(:)
        character(len=*),       intent(in   ) :: FILE
        integer,  optional,     intent(  out) :: RC

        integer :: STATUS
        character(len=ESMF_MAXSTR) :: IAm = 'MAPL_ClimUpdate'


        integer          :: I, M, M1, M2
        integer          :: NFLD
        integer          :: UNIT
        integer          :: DONE
        real             :: dum(1)

        type (ESMF_Field   ), pointer :: PREV(:)
        type (ESMF_Field   ), pointer :: NEXT(:)
        type (ESMF_DELayout)          :: LAYOUT
        type (ESMF_Grid    )          :: GRID


    ! --------------------------------------------------------------------------
    ! Allocate the number of fileds in the file
    ! --------------------------------------------------------------------------

        NFLD = size(NAMES)
        ASSERT_(NFLD>0)

        allocate(PREV(NFLD),stat=STATUS)
        VERIFY_(STATUS)
        allocate(NEXT(NFLD),stat=STATUS)
        VERIFY_(STATUS)

    ! --------------------------------------------------------------------------
    ! get the fields from the state
    ! --------------------------------------------------------------------------

        do I=1,NFLD
           call ESMF_StateGetField ( STATE, trim(NAMES(I))//'_PREV', PREV(I), RC=STATUS )
           VERIFY_(STATUS)
           call ESMF_StateGetField ( STATE, trim(NAMES(I))//'_NEXT', NEXT(I), RC=STATUS )
           VERIFY_(STATUS)
        end do

        call ESMF_FieldGet(PREV(1), GRID=GRID,    RC=STATUS)
        VERIFY_(STATUS)
        call ESMF_GridGet (GRID, DELayout=LAYOUT, RC=STATUS)
        VERIFY_(STATUS)

    ! --------------------------------------------------------------------------
    ! Find out the times of next, prev from the field attributes
    ! --------------------------------------------------------------------------

        call MAPL_FieldGetTime ( PREV(1), BEFORE, RC=STATUS )
        VERIFY_(STATUS)
        call MAPL_FieldGetTime ( NEXT(1), AFTER , RC=STATUS )
        VERIFY_(STATUS)

    ! --------------------------------------------------------------------------
    ! check to see if albedos need to be refreshed in the
    ! ESMF Internal State (prev, next need to surround
    ! the current time)
    ! --------------------------------------------------------------------------

        call ESMF_TimeGet ( BEFORE, yy=I, rc=STATUS )
        VERIFY_(STATUS)

        DONE = 0
        if( I > 0) then
           if( (BEFORE <= CURRENT_TIME) .and. (AFTER >= CURRENT_TIME)) then
              DONE = 1
           end if
        end if

        if(DONE /= 1) then

    ! --------------------------------------------------------------------------
    !  Get the midmonth times for the months before and after the current time
    ! --------------------------------------------------------------------------

           call MAPL_GetClimMonths ( CURRENT_TIME, BEFORE, AFTER,  RC=STATUS )
           VERIFY_(STATUS)

           call ESMF_TimeGet ( BEFORE, MM=M1, rc=STATUS )
           VERIFY_(STATUS)
           call ESMF_TimeGet ( AFTER , MM=M2, rc=STATUS )
           VERIFY_(STATUS)

    ! --------------------------------------------------------------------------
    !  Read the albedo climatologies from file
    ! --------------------------------------------------------------------------

           UNIT = GETFILE(FILE, form="unformatted",  RC=STATUS)
           VERIFY_(STATUS)

           DONE = 0
           do M=1,12
              if    (M==M1) then
                 do I=1,NFLD
                    call MAPL_VarRead(UNIT, PREV(I), RC=STATUS)
                    VERIFY_(STATUS)
                 end do
                 if(DONE==1) exit
                 DONE = DONE + 1
              elseif(M==M2) then
                 do I=1,NFLD
                    call MAPL_VarRead(UNIT, NEXT(I), RC=STATUS)
                    VERIFY_(STATUS)
                 end do
                 if(DONE==1) exit
                 DONE = DONE + 1
              else
                 do I=1,NFLD
                    call READ_PARALLEL(LAYOUT,DUM,UNIT,rc=status)
                    VERIFY_(STATUS)
                 end do
              end if
           end do

           call FREE_FILE ( Unit )
 
    ! --------------------------------------------------------------------------
    !  Reset the time on all fields
    ! --------------------------------------------------------------------------

           do I=1,NFLD
              call MAPL_FieldSetTime (  PREV(I), BEFORE, rc=STATUS )
              VERIFY_(STATUS)
              call MAPL_FieldSetTime (  NEXT(I), AFTER , rc=STATUS )
              VERIFY_(STATUS)
           end do
   
        endif

        deallocate(NEXT)
        deallocate(PREV)

        RETURN_(ESMF_SUCCESS)
      end subroutine MAPL_ClimUpdate


    subroutine MAPL_GetClimMonths ( CURRENT_TIME, BEFORE, AFTER, RC )
        type(ESMF_Time), intent(in ) :: CURRENT_TIME
        type(ESMF_Time), intent(out) :: BEFORE, AFTER
        integer,optional,intent(out) :: RC

        integer :: STATUS
        character(len=ESMF_MAXSTR) :: IAm = 'MAPL_GetClimMonths'

        integer                 :: MonthCurr
        type(ESMF_Time        ) :: midMonth
        type(ESMF_TimeInterval) :: oneMonth

        call ESMF_TimeIntervalSet(oneMonth, MM = 1, RC=STATUS )
        VERIFY_(STATUS)
        call ESMF_TimeGet(CURRENT_TIME, midMonth=midMonth, mm=MonthCurr, RC=STATUS )
        VERIFY_(STATUS)

        if( CURRENT_TIME < midMonth ) then
           AFTER    = midMonth
           midMonth = midMonth - oneMonth
           call ESMF_TimeGet (midMonth, midMonth=BEFORE, rc=STATUS )
           VERIFY_(STATUS)
        else
           BEFORE   = midMonth
           midMonth = midMonth + oneMonth
           call ESMF_TimeGet (midMonth, midMonth=AFTER , rc=STATUS )
           VERIFY_(STATUS)
        endif

        RETURN_(ESMF_SUCCESS)
    end subroutine MAPL_GetClimMonths
    
  subroutine MAPL_Skip(UNIT, LAYOUT, COUNT, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_DELayout)        , intent(IN   ) :: LAYOUT
    integer,           optional , intent(IN   ) :: COUNT
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: STATUS
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_Skip'
    integer                               :: N, NN

    if (MAPL_AM_I_ROOT(LAYOUT)) then
       if(present(COUNT)) then
          NN=COUNT
       else
          NN=1
       endif

       do N=1,NN
          read (unit=UNIT, IOSTAT=status)
          VERIFY_(STATUS)
       end do
    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_Skip

  subroutine MAPL_Backspace(UNIT, LAYOUT, COUNT, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_DELayout)        , intent(IN   ) :: LAYOUT
    integer,           optional , intent(IN   ) :: COUNT
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: STATUS
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_Backspace'
    integer                               :: N, NN

    if (MAPL_AM_I_ROOT(LAYOUT)) then
       if(present(COUNT)) then
          NN=COUNT
       else
          NN=1
       endif

       do N=1,NN
          backspace(unit=UNIT, IOSTAT=status)
          VERIFY_(STATUS)
       end do
    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_Backspace

  subroutine MAPL_Rewind(UNIT, LAYOUT, RC)

    integer                     , intent(IN   ) :: UNIT
    type (ESMF_DELayout)        , intent(IN   ) :: LAYOUT
    integer,           optional , intent(  OUT) :: RC

! Local variables

    integer                               :: STATUS
    character(len=ESMF_MAXSTR)            :: IAm='MAPL_Rewind'

    if (MAPL_AM_I_ROOT(LAYOUT)) then
       rewind(unit=UNIT, IOSTAT=status)
       VERIFY_(STATUS)
    end if
    
    RETURN_(ESMF_SUCCESS)
  end subroutine MAPL_Rewind

end module MAPL_IOMod
